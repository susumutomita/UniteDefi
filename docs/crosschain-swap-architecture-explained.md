# クロスチェインスワップ実装アーキテクチャ完全解説

## 🎯 核心的な理解：TEEは不要です

HTLCベースのアトミックスワップでは、暗号学的な保証によって安全性が確保されるため、信頼できる実行環境（TEE）は必要ありません。

## 📊 ブリッジ vs HTLCアトミックスワップ

### 従来のブリッジ方式
```
[Ethereum]                    [ブリッジ運営者]                    [NEAR]
    |                              |                               |
    |---(1) ETHをロック---------->|                               |
    |                              |---(2) 検証して指示---------->|
    |                              |                               |---(3) NEARをミント
    |                              |                               |
信頼が必要！ブリッジ運営者が悪意を持つと資金を失う
```

### HTLCアトミックスワップ方式（1inch Fusion+）
```
[Ethereum HTLC]                                              [NEAR HTLC]
    |                                                            |
    |---(1) ユーザーがETHをロック（ハッシュ付き）              |
    |                                                            |
    |                                               (2) リゾルバーがNEARをロック（同じハッシュ）
    |                                                            |
    |<-----------(3) シークレット公開------------------------>|
    |                                                            |
    |---(4) リゾルバーがETH受取         (5) ユーザーがNEAR受取--|

信頼不要！数学的に保証される。
```

## 🔄 実際の実装フロー

### 1. CLIツールの役割

CLIツールはオーケストレーターとして動作します。

```
┌─────────────────────────────────────────────────┐
│             CLIオーケストレーター                │
├─────────────────────────────────────────────────┤
│ 1. シークレット生成とハッシュ計算                │
│ 2. 両チェーンのエスクロー状態監視                │
│ 3. トランザクション送信のタイミング制御          │
│ 4. タイムアウト処理                              │
└─────────────────────────────────────────────────┘
         ↓                              ↓
    [Ethereum]                      [NEAR]
   スマートコントラクト          スマートコントラクト
```

### 2. 詳細な実行ステップ

```typescript
// CLIツールでの実装イメージ
class CrossChainSwapOrchestrator {
    async executeSwap() {
        // Step 1: シークレット生成
        const secret = crypto.randomBytes(32);
        const secretHash = sha256(secret);

        // Step 2: リゾルバーがNEAR側でエスクロー作成
        const nearEscrowId = await this.nearClient.createEscrow({
            beneficiary: userNearAddress,
            secretHash: secretHash,
            amount: "100 NEAR",
            timeouts: {
                finality: 30  60,      // 30分
                cancel: 60  60,        // 1時間
                publicCancel: 90  60   // 1.5時間
            }
        });

        // Step 3: ユーザーがEthereum側でエスクロー作成
        const ethEscrowId = await this.ethClient.createEscrow({
            beneficiary: resolverEthAddress,
            secretHash: secretHash,
            amount: "1 ETH",
            timeouts: {
                finality: 20  60,      // 20分（NEARより短い）
                cancel: 50  60,        // 50分
                publicCancel: 80  60   // 1.3時間
            }
        });

        // Step 4: 両方のエスクロー作成を確認
        await this.waitForBothEscrows(nearEscrowId, ethEscrowId);

        // Step 5: シークレット公開
        // NEARで先に公開（ユーザーが受け取る）
        await this.nearClient.claim(nearEscrowId, secret);

        // Step 6: Ethereumでもシークレットを使って受け取り
        await this.ethClient.claim(ethEscrowId, secret);
    }
}
```

## 🔐 なぜTEEが不要なのか

### HTLCの暗号学的保証

1. ハッシュロック
   - 同じシークレットがないと両方のエスクローを解除できない
   - SHA-256は一方向関数なので、ハッシュからシークレットは推測不可能

2. タイムロック
   - 明確な期限により、永久に資金がロックされることを防ぐ
   - 段階的な権限移譲で公平性を保つ

3. アトミック性
   - 両方成功するか、両方失敗するかの2択のみ
   - 片方だけ成功することは数学的に不可能

### TEEが必要になるケース
```
TEEが必要：
- 秘密鍵の管理
- オフチェーン計算の検証
- プライベートな状態の保持

HTLCでは不要：
- すべてオンチェーンで検証可能
- シークレットは公開されても問題ない（使用後）
- 状態はブロックチェーンに記録
```

## 🏗️ 実装アーキテクチャ

### 全体構成
```
┌─────────────────────────────────────────────────────────┐
│                    フロントエンド                        │
│                  （オプション：UI）                      │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                   CLIツール / SDK                        │
├─────────────────────────────────────────────────────────┤
│  - シークレット管理                                      │
│  - トランザクション構築                                  │
│  - 状態監視                                             │
│  - エラーハンドリング                                   │
└─────────────────────────────────────────────────────────┘
        ↓                                      ↓
┌──────────────────┐                  ┌──────────────────┐
│  Ethereum Node   │                  │   NEAR Node      │
│                  │                  │                  │
│  [HTLC Contract] │                  │  [HTLC Contract] │
└──────────────────┘                  └──────────────────┘
```

### CLIツールの実装構成
```
fusion-cli/
├── src/
│   ├── orchestrator.ts    # メインのオーケストレーション
│   ├── ethereum/
│   │   ├── client.ts      # Ethereum接続
│   │   ├── htlc.ts        # HTLCコントラクト操作
│   │   └── monitor.ts     # イベント監視
│   ├── near/
│   │   ├── client.ts      # NEAR接続
│   │   ├── htlc.ts        # HTLCコントラクト操作
│   │   └── monitor.ts     # イベント監視
│   ├── crypto/
│   │   └── secret.ts      # シークレット生成・検証
│   └── utils/
│       ├── timeout.ts     # タイムアウト管理
│       └── retry.ts       # リトライロジック
```

## 🚦 実行時のセキュリティ

### リゾルバーの実行環境
```
一般的な環境で十分：
- 通常のクラウドサーバー（AWS、GCP等）
- ローカルマシン
- Dockerコンテナ

必要な要件：
- インターネット接続
- 両チェーンのRPCアクセス
- 秘密鍵の安全な管理（通常のウォレットレベル）
```

### ユーザーの実行環境
```
- Webブラウザ + MetaMask/NEAR Wallet
- CLIツール（オプション）
- モバイルウォレット（将来的に）
```

## 💡 重要な洞察

### 1. 分散化の度合い
```
完全に分散化：
- HTLCコントラクト（オンチェーン）
- 検証ロジック（スマートコントラクト内）

部分的に中央集権：
- 1inchリレーヤー（注文配信）
- リゾルバーのマッチング

ユーザー視点では信頼不要：
- 最悪の場合でもタイムアウトで返金
```

### 2. 経済的インセンティブ
```
リゾルバーの利益：
- Dutch Auctionでの価格差
- 早期実行ボーナス

リゾルバーのリスク：
- ガス代の負担
- 価格変動リスク
- 技術的失敗のリスク

→ セーフティデポジットで軽減
```

## 🎯 まとめ

1. TEEは不要 - HTLCの暗号学的保証で十分
2. CLIツールは調整役 - 両チェインの操作を自動化
3. 信頼は最小限 - スマートコントラクトのコードのみ信頼
4. 実装はシンプル - 暗号技術の理解不要

これにより、ハッカソンの限られた時間内でも実装可能な、実用的なクロスチェインスワップシステムが構築できます。
